# การเขียนโปรแกรมแบบdeclarative(การประกาศ) (Sketch)

ในส่วนแรกของหนังสือเล่มนี้ผมได้เสนอว่าทั้งทฤษฎีcategoryและการเขียนโปรแกรมนั้นเกี่ยวกับความประกอบกันได้ ในการเขียนโปรแกรมคุณทำการแยกปัญหาไปเรื่อๆจนคุณถึงในระดับของรายระเอียดที่คุณสามารถทำงานกับมันได้ ทำการแก้ปัญหาย่อยๆในแต่ละตัวและทำการประกอบคำตอบใหม่จากล่างขึ้นบน ถ้าให้พูดแบบคล่าวๆได้มีสองวิธีในการทำแบบนี้คือการบอกคอมพิวเตอร์ในสิ่งที่ต้องทำหรือบอกวิธีการทำมัน ตัวหนึ่งเรียกว่าdeclarativeและอีกอันหนึ่งคือimperative

คุณสามารถเห็นสิ่งนี้แม้ในระดับที่พื้นฐานที่สุด การประกอบกันเองอาจจะถูกนิยามในแบบdeclarative เหมือนใน`h`คือการประกอบของ`g`ที่ตามมาจาก`f`

```Haskell
h = g . f
```

หรือในแบบของimperativeเหมือนในการเรียก`f`ก่อน จำผลของการเรียกนี้แล้วก็เรียก`g`กับผลลัพธ์

```Haskell
h x = let y = f x
      in g y
```

ในฉบับของโปรแกรมแบบimperativeนั้นมักจะถูกอธิบายในฐานะการกระทำต่อเนื่องที่ลำดับในเวลา โดยเฉพาะในการเรียก`g`ไม่สามารถเป็นไปได้ก่อนการใช้งาน`f`จะเสร็จก่อน อย่างน้อยนั่นคือภาพของแนวคิดในภาษาที่ขี้เกียจ(lazy)ที่มีการ*เรียกแบบเท่าที่ต้องการ*(*call-by-need*)ของการนำargumentมา การใช้งานจริงๆแล้วอาจจะดำเนินการในแบบที่แตกต่าง

ในความเป็นจริงถ้าขึ้นอยู่กับความฉลาดของcomplierแล้ว ไม่ค่อยมีความแตกต่างหรือแทบไม่มีระหว่างวิธีการที่โค้ดแบบ declarativeและimperativeจะถูกประมวล แต่ทั้งสองวิธีการนั้นมีความแตกต่างอย่างมาก ในวิธีการที่เราจะเข้าหาการแก้ปัญหาและในความสามารถในการดูแลและทดสอบของโค้ดที่ถูกเขียน

คำถามหลักคือในตอนที่เราเผชิญหน้ากับปัญหา เราจะมีทางเลือกระหว่างแนวทางของdeclarativeและimperativeในการแก้ไขมันตลอดหรือเปล่า? และถ้าได้มีคำตอบแบบdeclarativeแล้วมันสามารถถูกแปลไปยังโค้ดของคอมพิวเตอร์ได้หรือเปล่า? คำตอบของคำถามนี้นั้นใกลไปกว่าความชัดเจนและถ้าเราอาจจะหามันได้ เราอาจจะปฏิวัติความเข้าใจของเราของจักรวาล

ให้ผมได้อธิบายเพิ่ม ได้มีทวิลักษณ์(duality)คล้ายๆกันในฟิสิกส์ที่ทั้งชี้ไปยังบางหลักการที่ลึกชึ้งภายใต้ หรือบอกเราบางอย่างเกี่ยวกับวิธีการที่จิตใจทำงาน Richard Feynmanได้เอ่ยถึงถึงทวิลักษณ์นี้ในการเป็นแรงบันดาลใจของผลงานของเขาที่เกี่ยวกับ quantum
electrodynamics

ได้มีสองรูปแบบของการแสดงกฏส่วนใหญ่ของฟิสิกส์อกกมา หนึ่งในนั้นคือการใช้การพิจารณาเฉพาะแห่ง(local)หรือที่มีขนาดเล็กน้อยมาก(infinitesimal) เรามองไปที่สภาพของระบบในบริเวณข้างเคียง(neighborhood)รอบๆและทำการคาดเดาการที่มันจะค่อยๆเปลียนแปลงภายในเวลาถัดไปแบบฉับพลัน สิ่งนี้มักจะถูกแสดงโดนการใช้สมการdifferentialที่ต้องถูกintegratedหรือบวกรวมกันในช่วงๆหนึ่งของเวลา

สังเกตวิธีนี้นั้นมีความคล้ายกับการคิกแบบimperativeคือการที่เราไปยังคำตอบสุดท้ายโดยการตามเป็นลำดับของขั้นเล็กๆที่แต่ละตัวขึ้นอยู่กับผลลัพธ์ชองลำดับที่แล้ว ในความเป็นจริงแล้วการsimulationโดยคอมพิวเตอร์ของระบบทางฟิสิกส์นั้นโดยบ่อยครั้งถูกเขียนโดยการแปลงสมการdifferentialไปยังสมการdifferenceและทำการทำซ้ำมัน นี้คือวิธีการที่ยานอวกาศถูกทำให้เคลื่อนไหวได้ในเกมasteroids ในแต่ละขั้นของเวลา ตำแหน่งของยานอวกาศนันถูกเปลี่ยนโดยการบวกเพิ่มขึ้นอย่างเล็กน้อย ที่ถูกคำนวนโดยการคูณความเร็วของมันกับเวลาdelta ส่วนความเร็วนี้นก็ถูกเปลี่ยนโดยการบวกเพิ่มขึ้นอย่างเล็กน้อยในสัดส่วนของความเร่งที่ถูกให้มาโดยแรงหารด้วยมวล

![](images/asteroids.png){fig-align="center" height=200}

ได้มีการเขียนลงมาโดยตรงของสมการdiffferentialที่ตรงกันกับกฎการเคลื่อนที่ของNewton

$$
\begin{align*}
  F & = m \frac{dv}{dt} \\
  v & = \frac{dx}{dt}
\end{align*}
$$

ได้มีวิธีการคล้ายๆกันสามารถถูกใช้ในปัญหาที่ชับช้อนต่างๆอย่างการแพร่ขยายชองสนามแม่เหล็กไฟฟ้าโดนการใช้สมการของMaxwellหรือแม้กระทั่งพฤติกรรมของquarksและgluonsภายในprotonโดนการใช้QCD(quantum chromodynamics)แบบlattice 

การคิดแบบเฉพาะแห่งแบบนี้ถูกรวบกับการdiscretization(ทำให้เป็นช่วงๆ)ของพื้นที่และเวลาที่ถูกสนับสนุนโดยการใช้คอมพิวเตอร์แบบดิจิตอลได้แสดงออกมาอย่างสุดโต่งในความพยายามที่กล้าหาญของStephen Wolframในการลดความชับช้อนของจักรวาลทั้งหมดไปยังระบบของ cellular automata

ในอีกวิธีหนึ่งนั้นคือแบบสากล(global) เรามองไปที่สภาพเริ่มตันและสภาพสุดท้ายของระบบและคำนวนเส้นทางที่เชื่อมพวกมันโดยการลดขนาดของบางfunctional ตัวอย่างที่ง่ายที่สุดคือหลักการของเวลาที่น้อยที่สุดของFermat มันบอกว่าลำแสงที่แพร่ตามเส้นทางที่ใช้เวลาในการเดินทางที่น้อยที่สุด โดยเฉพาะในการไม่มีวัตถุที่สะท้อนหรือหักเห ลำแสงจากจุด$A$ไปยัง$B$จะใช้เส้นทางที่สั้นที่สุดที่ก็คือเส้นตรง แต่แสงจะเคลื่อนที่ในเวลาที่ช้าลงในวัสดุที่มีความหนาแน่น(และโปร่งแสง)อย่างน้ำหรือแก้วดังนั้นถ้าคุณเลือกจุดเริ่มต้นในอากาศและในจุดสุดท้ายภายใต้น้ำ มันนั้นมีประโยชน์มากกว่าสำหรับแสงที่จะเดินทางได้นานกว่าในอากาศและก็ใช้ทางลัดผ่านน้ำ เส้นทางของเวลาที่น้อยที่สุดทำให้ลำแสงหักเหที่ขอบระหว่างอากาศและน้ำผลที่ตามมาคือกฏการหักเหของSnell

$$
\frac{\sin(\theta_1)}{\sin(\theta_2)} = \frac{v_1}{v_2}
$$

ที่ที่$v_1$คือความเร็วของแสงในอากาศและ$v_2$คือความเร็วของแสงในน้ำ

![](images/snell.jpg){fig-align="center" height=200}

กลศาสตร์ดั้งเดิมทั้งหมดสามารถมาจากหลักการการกระทำที่น้อยที่สุด(principle of least
action) การกระทำสามารถถูกคำนวนสำหรับเส้นทางใดๆก็ตามโดนการทำการintegrate Lagrangianนั้นที่ก็คือความแตกต่างระหว่างพลังงานจลน์และพลังงานศักย์ (สังเกตว่า มันคือความแตกต่างไม่ใช่การบวกกัน หารบวกกันสามารถเป็นพลังงานทั้งหมด) ในตอนที่คุณยิงปืนครกเพื่อที่จะชนเป้าหมายที่ให้มา กระสุนยิงนั้นจะไปข้างบนก่อนที่พลังงานศักย์ที่มาจากแรงโน้มถ่วงนั้นมีมากกว่าและจะใช้บางเวลาตรงนั้นในการรวบรวมสิ่งที่ให้มาที่เป็นลบโดยการกระทำ แล้วมันจะเร่งความเร็วเพื่อที่จะเคลื่อนที่อย่างรวดเร็วผ่านพื้นที่ที่มีพลังงานศักย์น้อย

![](images/mortar.jpg){fig-align="center" height=200}

ผลงานของFeynmanที่ยิ่งใหญ่ที่สุดคือการนึงถึงได้ว่าหลักการการกระทำที่น้อยสามารถถูกใช้(generalized)ไปยังกลศาสตร์ควอนตัม ในอีกครั้งที่ปัญหาคือการแสดงออกในรูปสูตรของสภาพเริ่มต้นและสภาพสุดท้าย path integralของFeynmanระหว่างสภาพเหล่านี้ถูกใช้ในการคำนวนความเป็นไปได้ของการเปลี่ยนแปลง


![](images/feynman.jpg){fig-align="center" height=200}

ประเด็นอยู่ที่ว่าได้มีทวิลักษณ์ที่ไม่ได้ถูกอธิบายและน่าสนใจในการที่เราสามารถอธิบายกฏของphysics เราสามารถใช้ภาพแบบเฉพาะแห่งที่สิ่งต่างๆเกิดขึ้นเเป็นลำดับและในการเพื่มขึ้นอย่างเล็กๆ หรือเราสามารถใช้ภาพแบบสากลที่ที่เราประกาศเงื่อนไขเริ่มและเงื่อนไขสุดท้ายและทุกๆอย่างระหว่างมันก็จะตามมา

ในวิธีทางแบบสากลก็สามารถถูกใช้ในการเขียนโปรแกรมตัวอย่างเช่นในการเขียนray tracing เราประกาศตำแหน่งของตาและตำแหน่งของแหล่งของแสง และหาเส้นทางที่ลำแสงอาจจะเชื่อมพวกมันเข้าด้วยกัน เราไม่ได้ลดเวลาในการเคลื่อนที่อยากเปิดเผยของแต่ละลำแสง แต่เราใช้กฏของSnellและเรขาคณิตของการสะท้อนที่ที่ได้ผลเหมือนกัน

ความแตกต่างที่ใหญ่ที่สุดระหว่างวิธีแบบเฉพาะแห่งและแบบสากลคือการที่พวกมันพิจารณาพื้นที่และสำคัญไปกว่านั้นคือเวลา วิธีแบบเฉพาะแห่งยอมรับความพึงพอใจแบบฉับพลันของที่นี้และตรงนี้ในขณะที่วิธีแบบสากลนั้น มุมมองที่อยู่กับที่ในระยะยาวอย่างกับว่าอนาคตได้ถูกกำหนดไว้แล้วและเราแค่วิเคราะห์คุณสมบัติของจักรวาลนิรันดร

ไม่มีที่ไหนที่สามารถจะแสดงให้เห็นได้ดีไปกว่าแนวทางขอFunctional Reactive Programming (FRP)กับการปฏิสัมพันธ์ของผู้ใช้ โดยแทนที่จะเขียนhandlersแยกกันสำหรับการกระทำของผู้ใช้ในทุกๆรูปแบบ ทั้งหมดมีการเข้าถึงต่อstateที่เป็นส่วนรวมและสามารถเปลี่ยนได้ FRPพิจารณาเหตุการภายนอกในฐานะรายการที่ไม่มีที่สิ้นสุดและใช้การเปลี่ยนแปลงหลายๆอย่างกับมัน ในทางแนวคิดแล้ว รายการของการกระทำของเรานั้นอยู่ที่นี้และมีอยู่แล้วในฐานะข้องมูลinputกับโปรแกรมของเรา ในมุมมองของโปรแกรม ไม่มีความแตกต่างระหว่างlistของตัวเลขของ$\pi$ listของเลขสุ่มเทียมหรือlistของตำแหน่งmouseที่มาจากhardwareของคอมพิวเตอร์ ในแต่ละกรณีถ้าคุณต้องไปยังตัวเลขในตำแหน่งที่$n$th คุณต้องผ่านทั้ง$n-1$ตัวเลขก่อน ในตอนใช้กับเหตุการที่ขึ้นกับเวลา เราเรียกคุณสมบัตินี้ว่า*causality*(ความสัมพันธ์ระหว่างเหตุและผล) 

แล้วสิ่งนี้เกี่ยวกับทฤษฎีcategoryอย่างไร? ผมจะเสนอว่าทฤษฎีcategoryนั้นสนับสนุนแนวทางแบบสากรและดังนั้นรองรับการเขียนโปรแกรมแบบdeclarative ก่อนอื่นเลยคือไม่เหมือนcalculus มันไม่มีเครื่องหมาย ที่มีอยู่แล้วของระยะทางหรือบริเวณข้างเคียงหรือเวลา สิ่งที่เรามีอยู่ทั้งหมดคือวัตถุนามธรรมและการเชื่อมต่อที่เป็นนามธรรมระหว่างมัน ถ้าคุณสามารถไปจาก$A$ไปยัง$B$ผ่านลำดับของขั้นต่างๆ คุณสามารถที่จะไปได้ในกระโดดครั้งเดียว มากไปกว่านั้น เครื่องมือส่วนใหญ่ทฤษฎีcategoryคือการสร้างแบบสากลที่เป็นจุดสูงสุดของแนวทางแบบสากล เราได้เห็นมันในการใช้งานแล้ว ตัวอย่างเช่นในนิยามของproductแบบcategorical มันสามารถถูกทำได้โดยการกำหนดคุณสมบัติของมัน (ที่เป็นแนวทางที่declarativeอย่างมาก มันคือวัตถุที่ทีprojectionสองตัวและเป็นวัตถุที่ดีที่สุด) มันทำให้บางคุณสมบัติดีที่สุคนั้นก็คือคุณสมบัติของการแยกตัวประกอบของprojectionของวัตถุอื่นๆ

![](images/productranking.jpg){fig-align="center" height=200}


เทียวกับหลักการของเวลาที่น้อยที่สุดของFermatหรือหลักการการกระทำที่น้อยที่สุด

ในทางกลับกัน แตกต่างกับนิยามที่มีมาก่อนของproductแบบCartesianที่มีความimperativeมากกว่า คุณนิยามวิธีการสร้างสมาชิกของproductโดยการเลือกหนึ่งสมาชิกของsetหนึ่งและสมาชิกอีกตัวจากอีกsetหนึ่ง มันคือสูตรในการสร้างpairและนั้นคืออีกวิธีหนึ่งในการแยกส่วนของpair

ในแทบทุกๆภาษาโปรแกรมรวมไปถึงภาษาfunctionalเหมือนHaskell typeแบบproduct coproduct functiion นั้นถูกสร้างแล้วแทนที่จะถูกนิยามโดยการสร้างแบบสากล ถึงแม้ได้มีความพยายามในการสร้างภาษาโปรแกรมแบบcategory (อย่างวิทยานิพนธ์ของTatsuya Hagino[^1])

ไม่ว่าจะใช้มันโดยตรงหรือไม่ นิยามแบบcategoryพิสูจน์ว่าการสร้างแบบโปรแกรมที่มีอยู่แล้วนั้นถูกต้องแลัวก็ทำให้เกิดการสร้างใหม่ๆ สำคัญไปกว่านี้คือทฤษฎีcategoryให้ ภาษาของภาษา( meta-language)สำหรับการให้เหตุผลเกี่ยวกับโปรแกรมคอมพิวเตอร์ในระดับของการประกาศ มันก็สนับสนุนการให้เหตุผลเกี่ยวกับกฏเกณฑ์ของปัญหาก่อนที่มันจะถูกเขียนไปในโค้ด


[^1]: [http://web.sfc.keio.ac.jp/~hagino/thesis.pdf](http://web.sfc.keio.ac.jp/~hagino/thesis.pdf)



