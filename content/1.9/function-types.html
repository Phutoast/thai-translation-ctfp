<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ทฤษฎีcategoryสำหรับโปรแกรมเมอร์ - 10&nbsp; TypeประเภทFunctions (Draft)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../content/1.10/natural-transformations.html" rel="next">
<link href="../../content/1.8/functoriality.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../content/1.1/category-the-essence-of-composition.html">Part 1</a></li><li class="breadcrumb-item"><a href="../../content/1.9/function-types.html"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">TypeประเภทFunctions (Draft)</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">ทฤษฎีcategoryสำหรับโปรแกรมเมอร์</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Translator’s Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/0.0/preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">คำนำ (Draft)</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Part 1</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/1.1/category-the-essence-of-composition.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Category: แก่นแท้ของการประกอบเข้าด้วยกัน (Draft)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/1.2/types-and-functions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Typeและfunction (Draft)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/1.3/categories-great-and-small.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Categoryทั้งเล็กและใหญ่ (Draft)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/1.4/kleisli-categories.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">CategoryแบบKleisli (Draft)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/1.5/products-and-coproducts.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">ProductและCoproduct (Draft)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/1.6/simple-algebraic-data-types.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Typeข้อมูลแบบAlgebraicอย่างง่าย (Simple Algebraic Data Types) (Draft)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/1.7/functors.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Functors (Draft)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/1.8/functoriality.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">ความเป็นFunctor (Draft)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/1.9/function-types.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">TypeประเภทFunctions (Draft)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/1.10/natural-transformations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Natural Transformation (การแปลงแบบธรรมชาติ) (Sketch)</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Part 2</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/2.1/declarative-programming.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">การเขียนโปรแกรมแบบdeclarative(การประกาศ) (Sketch)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/2.2/limits-and-colimits.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">LimitและColimit (Sketch)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/2.3/free-monoids.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Monoidแบบอิสระ(Free Monoid) (Sketch)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/2.4/representable-functors.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Functorที่มีตัวแทนได้ (Sketch)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/2.5/the-yoneda-lemma.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">LemmaของYoneda (Sketch)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/2.6/yoneda-embedding.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">การEmbeddingของYoneda (Sketch)</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
 <span class="menu-text">Part 3</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/3.1/its-all-about-morphisms.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">มันเกี่ยวกับmorphismทั้งหมด (Sketch)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/3.2/adjunctions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Adjunctions (Sketch)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/3.3/free-forgetful-adjunctions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Adjunctionอิสระ(Free)/ทำให้ลืม(Forgetful) (Sketch)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/3.4/monads-programmers-definition.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Monadsในนิยามของโปรแกรมเมอร์ (Sketch)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/3.5/monads-and-effects.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">22</span>&nbsp; <span class="chapter-title">Monadและผลตามมา(Effect) (Sketch)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/3.6/monads-categorically.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">23</span>&nbsp; <span class="chapter-title">MonadในแบบCategory (Sketch)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/3.7/comonads.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">24</span>&nbsp; <span class="chapter-title">Comonads (Sketch)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/3.8/f-algebras.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">25</span>&nbsp; <span class="chapter-title">F-Algebras (Sketch)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/3.9/algebras-for-monads.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">26</span>&nbsp; <span class="chapter-title">AlgebrasสำหรับMonads (Sketch)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/3.10/ends-and-coends.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">27</span>&nbsp; <span class="chapter-title">EndsและCoends (Sketch)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/3.11/kan-extensions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">28</span>&nbsp; <span class="chapter-title">ส่วนขยายKan (Sketch)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/3.12/enriched-categories.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">29</span>&nbsp; <span class="chapter-title">Categoryที่ถูกเพิ่มค่า(Enriched Categories) (Sketch)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/3.13/topoi.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">30</span>&nbsp; <span class="chapter-title">Topoid (Sketch)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/3.14/lawvere-theories.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">31</span>&nbsp; <span class="chapter-title">ทฤษฎีแบบLawvere (Lawvere Theories) (Sketch)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/3.15/monads-monoids-and-categories.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">32</span>&nbsp; <span class="chapter-title">Monads Monoids และ Categoryต่างๆ (Sketch)</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/etc/glossary.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">33</span>&nbsp; <span class="chapter-title">คำเฉพาะและคำแปลของมัน</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/etc/acknowledgments.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">34</span>&nbsp; <span class="chapter-title">Original Book’s Acknowledgments (Sketch)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/etc/colophon.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">35</span>&nbsp; <span class="chapter-title">Original Book’s Colophon (Sketch)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../content/etc/copyleft.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">36</span>&nbsp; <span class="chapter-title">Original Book’s Copyleft Notice (Sketch)</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#การสรางแบบสากล-universal-construction" id="toc-การสรางแบบสากล-universal-construction" class="nav-link active" data-scroll-target="#การสรางแบบสากล-universal-construction"><span class="header-section-number">10.1</span> การสร้างแบบสากล (Universal Construction)</a></li>
  <li><a href="#การcurry" id="toc-การcurry" class="nav-link" data-scroll-target="#การcurry"><span class="header-section-number">10.2</span> การCurry</a></li>
  <li><a href="#exponential" id="toc-exponential" class="nav-link" data-scroll-target="#exponential"><span class="header-section-number">10.3</span> Exponential</a></li>
  <li><a href="#categoryแบบcartesian-closed" id="toc-categoryแบบcartesian-closed" class="nav-link" data-scroll-target="#categoryแบบcartesian-closed"><span class="header-section-number">10.4</span> CategoryแบบCartesian Closed</a></li>
  <li><a href="#typeประเภทขอมลแบบพชคณตและexponentials" id="toc-typeประเภทขอมลแบบพชคณตและexponentials" class="nav-link" data-scroll-target="#typeประเภทขอมลแบบพชคณตและexponentials"><span class="header-section-number">10.5</span> Typeประเภทข้อมูลแบบพีชคณิตและexponentials</a>
  <ul class="collapse">
  <li><a href="#ยกกำลงศนย" id="toc-ยกกำลงศนย" class="nav-link" data-scroll-target="#ยกกำลงศนย"><span class="header-section-number">10.5.1</span> ยกกำลังศูนย์</a></li>
  <li><a href="#ยกกำลงของหนง" id="toc-ยกกำลงของหนง" class="nav-link" data-scroll-target="#ยกกำลงของหนง"><span class="header-section-number">10.5.2</span> ยกกำลังของหนึ่ง</a></li>
  <li><a href="#ยกกำลงหนง" id="toc-ยกกำลงหนง" class="nav-link" data-scroll-target="#ยกกำลงหนง"><span class="header-section-number">10.5.3</span> ยกกำลังหนึ่ง</a></li>
  <li><a href="#ยกกำลงของผลบวก" id="toc-ยกกำลงของผลบวก" class="nav-link" data-scroll-target="#ยกกำลงของผลบวก"><span class="header-section-number">10.5.4</span> ยกกำลังของผลบวก</a></li>
  <li><a href="#exponentialsของexponentials" id="toc-exponentialsของexponentials" class="nav-link" data-scroll-target="#exponentialsของexponentials"><span class="header-section-number">10.5.5</span> ExponentialsของExponentials</a></li>
  <li><a href="#exponentialsบนproduct" id="toc-exponentialsบนproduct" class="nav-link" data-scroll-target="#exponentialsบนproduct"><span class="header-section-number">10.5.6</span> Exponentialsบนproduct</a></li>
  </ul></li>
  <li><a href="#isomorphismของcurry-howard" id="toc-isomorphismของcurry-howard" class="nav-link" data-scroll-target="#isomorphismของcurry-howard"><span class="header-section-number">10.6</span> IsomorphismของCurry-Howard</a></li>
  <li><a href="#บรรณานกรม" id="toc-บรรณานกรม" class="nav-link" data-scroll-target="#บรรณานกรม"><span class="header-section-number">10.7</span> บรรณานุกรม</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../content/1.1/category-the-essence-of-composition.html">Part 1</a></li><li class="breadcrumb-item"><a href="../../content/1.9/function-types.html"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">TypeประเภทFunctions (Draft)</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">TypeประเภทFunctions (Draft)</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>มาจนถึงจุดนี้ผมได้ข้ามความหมายของtypeประเภทfunctions typeประเภทfunctionนั้นมีความแตกต่างจากtypeอื่นๆ</p>
<p>ดู<code>Integer</code>เป็นตัวอย่าง มันก็แค่setของจำนวนเต็ม <code>Bool</code>คือsetที่มีสองสมาชิก แต่typeแบบfunction<span class="math inline">\(a\rightarrow b\)</span>นั้นมีมากว่านั้น มันคือsetของmorphismระหว่างวัตถุ<span class="math inline">\(a\)</span>และ<span class="math inline">\(b\)</span> setของmorphismระหว่างวัตถุทั้งสองในcategoryจะถูกเรียกว่าhom-set โดยที่ในcategory<span class="math inline">\(\textbf{Set}\)</span>ทุกๆhom-setเองคือวัตถุในcategoryเช่นกัน เพราะในที่สุดแล้วมันคือ<em>set</em></p>
<div id="fig-hanno" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-hanno-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/set-hom-set.jpg" height="200" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-hanno-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10.1: hom-setใน<span class="math inline">\(\textbf{Set}\)</span>ก็เป็นแค่set
</figcaption>
</figure>
</div>
<p>สิ่งแบบนี้ไม่จริงในcategoryอื่นๆที่hom-setนั้นอยู่ภายนอกcategory ยิ่งกว่านั้นพวกมันถูกเรียกว่าhom-set<em>ภายนอก</em> (<em>external</em> hom-sets)</p>
<div id="fig-hanno" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-hanno-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/hom-set.jpg" height="200" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-hanno-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10.2: hom-setใน<span class="math inline">\(\textbf{C}\)</span>เป็นsetภายนอก
</figcaption>
</figure>
</div>
<p>มันคือธรรมชาติในการอ้างอิงตนเองของcategory<span class="math inline">\(\textbf{Set}\)</span> ที่ทำให้typeประเภทfunctionsมีความพิเศษ แต่มันก็มีวิธีคล้ายๆกันในการสร้างวัตถุที่แสดงแทนhom-setที่อย่างน้อยก็แยู่ในบางcategory วัตถุแบบนี้ถูกเรียกว่าhom-set<em>ภายใน</em> (<em>internal</em> hom-set)</p>
<section id="การสรางแบบสากล-universal-construction" class="level2" data-number="10.1">
<h2 data-number="10.1" class="anchored" data-anchor-id="การสรางแบบสากล-universal-construction"><span class="header-section-number">10.1</span> การสร้างแบบสากล (Universal Construction)</h2>
<p>เรามาลืมสักครู่ว่าtypeประเภทfunctionsคือset และลองที่จะสร้างtypeประเภทfunctionsหรือโดยทั่วไปก็คือhom-setภายในจากศูนย์ เหมือนทุกๆครั้งไป เราจะหาทางจากcategory<span class="math inline">\(\textbf{Set}\)</span> แต่จะหลีกเลี่ยงการใช้คุณสมบัติโดยเฉพาะของsetใดๆก็ตามอย่างระมัดระวัง เพื่อที่ว่าการสร้างนั้นจะสามารถใช้งานได้ในcategoryอื่นๆได้</p>
<p>typeประเภทfunctionsอาจจะถูกพิจารณาเป็นtypeประกอบ เพราะว่ามันมีความสัมพันธ์ระหว่างtypeของargumentและtypeของreturn เราได้เห็นการสร้างของtypeประกอบแล้ว ที่ที่ต้องมีความเกี่ยวข้องกับความสัมพันธ์ระหว่างวัตถุต่างๆ และได้ใช้การสร้างแบบสากลในการนิยาม<a href="../../content/1.5/products-and-coproducts.html">typeแบบproductและcoproduct</a> เราสามารถที่จะใช้เคล็ดลับเดียวกันในการนิยามtypeประเภทfunctions เราต้องการรูปแบบที่เกี่ยวกับสามวัตถุนี้นั้นก็คือ typeประเภทfunctionsที่เรากำลังสร้าง typeของargumentและtypeของreturn</p>
<p>รูปแบบที่ตรงไปตรงมาที่สุดที่ทำการเชื่อมต่อtypeทั้งสามเข้าด้วยกัน ถูกเรียกว่าการ<em>ใช้งานfunction</em>(<em>function application</em>)หรือ<em>การประเมิน</em>(<em>evaluation</em>) ถ้ามีสิ่งที่มีคุณสมบัติของtypeประเภทfunctions ที่เราจะเรียกมันว่า<span class="math inline">\(z\)</span> (สังเกตว่าถ้าเราไม่อยู่ในcategory<span class="math inline">\(\textbf{Set}\)</span>สิ่งนี่ก็คือวัตถุเหมือนวัตถุอื่นๆ) และtypeของargument<span class="math inline">\(a\)</span>(ที่เป็นวัตถุ) การใช้งานโยงคู่ๆนี้ไปยังtypeของผลลัพธ์<span class="math inline">\(b\)</span>(ที่เป็นวัตถุ) เราได้มีวัตถุสามตัว สองในสามนั้นคงที่(ที่ก็คือเป็นตัวแทนของtypeของargumentและtypeของreturn)</p>
<p>เราก็จะมีการใช้งานที่ก็คือการโยง แล้วเราจะนำการโยงเหล่านี้ไปยังรูปแบบของเราได้อย่างไร? ถ้าเราได้รับอนุญาตในการมองลงไปในวัตถุต่างๆ เราสามารถจับคู่function<span class="math inline">\(f\)</span> (ที่เป็นสมาชิกของ<span class="math inline">\(z\)</span>)กับargument<span class="math inline">\(x\)</span>(ที่เป็นสมาชิกของ<span class="math inline">\(a\)</span>) และโยงมันไปยัง<span class="math inline">\(fx\)</span>(เป็นสมาชิกของ<span class="math inline">\(b\)</span>และเป็นผลของการใช้งานของ<span class="math inline">\(f\)</span>บน<span class="math inline">\(x\)</span>)</p>
<div id="fig-hanno" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-hanno-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/set-hom-set.jpg" height="200" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-hanno-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10.3: ใน<span class="math inline">\(\textbf{Set}\)</span>เราสามารถเลือกfunction<span class="math inline">\(f\)</span>จากsetของfunction<span class="math inline">\(z\)</span>และเราสามารถเลือกargument<span class="math inline">\(x\)</span>จากset(หรือtype)<span class="math inline">\(a\)</span> เราสามารถได้สมาชิก<span class="math inline">\(fx\)</span>ในset(หรือtype)<span class="math inline">\(b\)</span>
</figcaption>
</figure>
</div>
<p>แต่แทนที่จะทำงานกับคู่ๆเดียว<span class="math inline">\((f,x)\)</span> เราสามารถที่จะพูดเกี่ยวกับ<em>product</em>ทั้งหมดของtypeประเภทfunctions<span class="math inline">\(z\)</span>และtypeของargument<span class="math inline">\(a\)</span>เช่นกัน product<span class="math inline">\(z\times a\)</span>คือวัตถุและเราสามารถที่จะเลือกลูกศร<span class="math inline">\(g\)</span>จากวัตถุนั้นไปยัง<span class="math inline">\(b\)</span>ในฐานะmorphismในการใช้งาน ใน<span class="math inline">\(\textbf{Set}\)</span> <span class="math inline">\(g\)</span>อาจจะเป็นfunctionที่โยงทุกๆคู่<span class="math inline">\((f, x)\)</span>ไปยัง<span class="math inline">\(fx\)</span></p>
<p>ดังนั้นรูปแบบ(ของเรา)คือproductระหว่างสองวัตถุ<span class="math inline">\(z\)</span>และ<span class="math inline">\(a\)</span> ที่ถูกต่อไปยังอีกวัตถุ<span class="math inline">\(b\)</span> โดยmorphism<span class="math inline">\(g\)</span></p>
<div id="fig-hanno" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-hanno-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/functionpattern.jpg" height="200" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-hanno-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10.4: รูปแบบของวัตถุและmorphismที่เป็นจุดเริ่มต้นของการสร้างแบบสากล
</figcaption>
</figure>
</div>
<p>แล้วสิ่งนี้เฉพาะเจาะจงพอหรือยังในการแยกtypeประเภทfunctionsโดยการใช้การสร้างแบบสากล? ไม่ใช่ในทุกๆcategory แต่ในcategoryที่เราสนใจมันก็พอแล้ว และอีกคำถามหนึ่ง เป็นไปได้หรือเปล่าในการนิยามวัตถุประเภทfunctionsโดยที่ไม่ต้องนิยามproductก่อน? เพราะว่าเราก็มีcategoryที่ไม่มีproductหรือไม่มีproductสำหรับทุกๆคู่ของวัตถุ คำตอบคือไม่ มันไม่มีtypeประเภทfunctionsถ้าไม่มีtypeประเภทproduct เราจะกลับมาในสิ่งนี้หลังจากที่เราพูดถึงexponential</p>
<p>เรามาทบทวนการสร้างแบบสากล เราเริ่มจากรูปแบบของวัตถุต่างๆและmorphism นั้นคือการหาที่คลุมเครือและมักจะได้ผลลัพธ์ที่มากมาย โดยเฉพาะใน<span class="math inline">\(\textbf{Set}\)</span>ที่แทบทุกๆอย่างนั้นต่อกับทุกๆอย่าง เราสามารถนำวัตถุอะไรก็ได้<span class="math inline">\(z\)</span>มารวมกับ<span class="math inline">\(a\)</span>เพื่อที่จะเป็นproductและก็จะมีfunctionจากสิ่งนี้ไปยัง<span class="math inline">\(b\)</span>(ยกเว้นแต่<span class="math inline">\(b\)</span>จะเป็นsetว่าง)</p>
<p>ดังนั้นการรที่เราใช้การจัดอันดับที่ก็เป็นอาวุธลับของเรา สิ่งนี้มักจะถูกทำโดยความต้องการที่จะมีการโยงที่เป็นเอกลักษณ์(และอันเดียว)ระหว่างวัตถุที่มีคุณสมบัติต่างๆ เป็นการโยงที่ทำการแยกตัวประกอบการสร้างของเรา ในกรณีของเราเราจะประกาศว่า<span class="math inline">\(z\)</span>มาคู่กับmorphism<span class="math inline">\(g\)</span>จาก<span class="math inline">\(z\times a\)</span>ไปยัง<span class="math inline">\(b\)</span> นั้น<em>ดีกว่า</em><span class="math inline">\(z\)</span>ตัวอื่นๆที่มีการใช้งานเป็นของตนเอง<span class="math inline">\(g'\)</span>ก็ต่อเมื่อได้มีการโยงที่เป็นเอกลักษณ์(และอันเดียว)<span class="math inline">\(h\)</span> จาก<span class="math inline">\(z'\)</span>ไปยัง<span class="math inline">\(z\)</span>ในแบบที่ว่าการใช้งานของ<span class="math inline">\(g'\)</span>แยกตัวประกอบผ่านการใช้งานของ<span class="math inline">\(g\)</span> (คำใบ้:อ่านประโยคนี้ในขณะมองรูปๆนี้)</p>
<div id="fig-hanno" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-hanno-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/functionranking.jpg" height="200" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-hanno-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10.5: ทำการสร้างการจัดลำดับระหว่างวัตถุประเภทfunctionsที่มีคุณสมบัติ
</figcaption>
</figure>
</div>
<p>ในตอนนี้คือส่วนที่ค่อนข้างยากและคือเหตุผลหลักที่ผมเลื่อนการสร้างแบบสากลนี้ออกไปจนถึงตอนนี้ ได้มีmorphism<span class="math inline">\(h::z'\rightarrow z\)</span>เราต้องการที่จะปิดdiagramที่มีทั้ง<span class="math inline">\(z\)</span>และ<span class="math inline">\(z'\)</span>คูณกับ<span class="math inline">\(a\)</span> สิ่งที่เราต้องการจริงๆคือการโยงจาก<span class="math inline">\(z'\times a\)</span>และ<span class="math inline">\(z\times a\)</span>ถ้ามีการโยง<span class="math inline">\(h\)</span>จาก<span class="math inline">\(z'\)</span>ไปยัง<span class="math inline">\(z\)</span> และในตอนนี้หลังจากการสนทนาของความเป็นfunctorของproductเรารู้วิธีการทำมัน เพราะว่าproductมันเองเป็นfunctor(หรือให้แม่นยำคือendo-bi-functor) มันเป็นไปได้ที่จะliftคู่ของmorphisms หรือในอีกความหมายหนึ่งเราสามารถที่จะนิยามไม่แค่productของวัตถุต่างๆแต่รวมไปถึงproductของmorphism</p>
<p>เนื่อด้วยว่าเราไม่ได้แตะชิ้นส่วนที่สองของproduct<span class="math inline">\(z'\times a\)</span> เราจะทำการliftคู่ของmorphism<span class="math inline">\((h,\operatorname{id})\)</span> ในที่นี้<span class="math inline">\(\operatorname{id}\)</span>คือidentityของ<span class="math inline">\(a\)</span></p>
<p>ดังนั้นนี่คือวิธีการที่เราจะแยกตัวประกอบการใช้งานหนึ่งของ<span class="math inline">\(g\)</span>จากการใช้งานของ<span class="math inline">\(g'\)</span></p>
<p><span class="math display">\[
g'=g\circ(h\times\operatorname{id})
\]</span></p>
<p>กุญแจสำคัญคือการกระทำของproductบนmorphism</p>
<p>ในส่วนที่สามคือการสร้างแบบสากลโดยการเลือกวัตถุที่ดีในสากล เรามาเรียกวัตถุนี้ว่า <span class="math inline">\(a\Rightarrow b\)</span> (คิดถึงสิ่งนี้ในฐานะชื่อทางสัญลักษณ์สำหรับวัตถุหนึ่ง ไม่ที่จะสับสนกับ ความต้องการ(constraint)ของtypeclassของHaskell โดยที่ผมจะคุยเกี่ยวกับหลายๆวิธีในการตั้งชื่อในอีกไม่นาน) วัตถุนี้มาคู่กับการใช้งานของมันที่ก็คือmorphismจาก<span class="math inline">\((a\Rightarrow b)\times a\)</span>ไปยัง<span class="math inline">\(b\)</span>ที่เราจะเรียกว่า<em>eval</em> วัตถุ<span class="math inline">\(a\Rightarrow b\)</span>คือสิ่งที่ดีที่สุดถ้าวัตถุอื่นที่มีคุณสมบัติสำหรับวัตถุประเภทfunctionsสามารถถูกโยงได้อย่างเป็นเอกลักษณ์(และอันเดียว) ไปยังมันในรูปแบบที่ว่าmorphismการใช้งานของมันอย่างๆ<span class="math inline">\(g\)</span>แยกตัวประกอบผ่าน<em>eval</em> วัตถุนี่นั้นดีกว่าวัตถุอื่นๆตามการจัดอำดับของเรา</p>
<p>หรือถ้าให้เป็นอย่างทางการ</p>
<blockquote class="blockquote">
<p>วัตถุประเภทfunctionsจาก<span class="math inline">\(a\)</span>ไปยัง<span class="math inline">\(b\)</span>คือวัตถุ<span class="math inline">\(a\Rightarrow b\)</span> คู่กับmorphimsอย่าง<span class="math display">\[\operatorname{eval}::((a\Rightarrow b)\times a)\rightarrow b\]</span>เพื่อที่ว่าสำหรับวัตถุอื่นๆที่คู่กับmorphismอย่าง<span class="math display">\[g::z\times a\rightarrow b\]</span>ได้มีmorphismที่เป็นเอกลักษณ์(และอันเดียว)อย่าง<span class="math display">\[h::z\rightarrow(a\Rightarrow b)\]</span>ที่แยกตัวประกอบ<span class="math inline">\(g\)</span>ผ่าน<span class="math inline">\(\operatorname{eval}\)</span> <span class="math display">\[g=\operatorname{eval}\circ(h\times\operatorname{id})\]</span></p>
</blockquote>
<p>แน่นอนว่าไม่มีการรับประกันว่าวัตถุอย่าง<span class="math inline">\(a\Rightarrow b\)</span>มีอยู่สำหรับคู่ของ<span class="math inline">\(a\)</span>และ<span class="math inline">\(b\)</span>ใดๆก็ตามในcategoryที่ให้มา แต่มันมีอยู่ใน<span class="math inline">\(\textbf{Set}\)</span> มากไปกว่านั้นใน<span class="math inline">\(\textbf{Set}\)</span>วัตถุนี้นั้นisomorphicกับhom-set<span class="math inline">\(\textbf{Set}(a,b)\)</span></p>
<p>นี้คือเหตุผลในHaskellที่เราตีความtypeประเภทfunction<code>a -&gt; b</code> ในฐานะวัตถุประเภทfunctionsทางcategroy<span class="math inline">\(a\Rightarrow b\)</span></p>
</section>
<section id="การcurry" class="level2" data-number="10.2">
<h2 data-number="10.2" class="anchored" data-anchor-id="การcurry"><span class="header-section-number">10.2</span> การCurry</h2>
<p>เรามาดูอีกรอบในวัตถุประเภทfunctionsที่มีคุณสมบัติครบทั้งหมด แต่ในตอนนี้เรามาคิดถึงmorphism<span class="math inline">\(g\)</span>ในฐานะfunctionที่มีสองตัวแปร<span class="math inline">\(z\)</span>และ<span class="math inline">\(a\)</span></p>
<p><span class="math display">\[
g::z\times a\rightarrow b
\]</span></p>
<p>การเป็นmorphismจากproductแทบจะเป็นเหมือนการเป็นfunctionที่มีสองตัวแปร โดยเฉพาะใน<span class="math inline">\(\textbf{Set}\)</span>ที่<span class="math inline">\(g\)</span>คือfunctionจากคู่ของค่าต่างๆ ที่หนึ่งในนั้นมาจากset<span class="math inline">\(z\)</span>และอีกตัวที่มาจากset<span class="math inline">\(a\)</span></p>
<p>ในอีกทางหนึ่ง คุณสมบัติสากลบอกเราว่าแต่ละ<span class="math inline">\(g\)</span>ได้มีmorphism<span class="math inline">\(h\)</span>ที่โยง<span class="math inline">\(z\)</span>ไปยัง วัตถุประเภทfunctionอย่าง<span class="math inline">\(a\Rightarrow b\)</span></p>
<p><span class="math display">\[
h::z\rightarrow\big(a\Rightarrow b\big)
\]</span></p>
<p>ใน <span class="math inline">\(\textbf{Set}\)</span>นี่หมายความว่า<span class="math inline">\(h\)</span>คือfunctionที่นำตัวแปรเดี่ยวของtype<span class="math inline">\(z\)</span> และคืนค่าให้เป็นfunctionจาก<span class="math inline">\(a\)</span>และ<span class="math inline">\(b\)</span> นั้นทำให้<span class="math inline">\(h\)</span>เป็นfunctionที่higher order ดังนั้นการสร้างแบบสากลสร้างความตรงกันแบบหนึ่งต่อหนึ่งระหว่างfunctionที่มีสองตัวแปร และfunctionที่มีตัวแปรเดี่ยวที่คืนค่าเป็นfunction ความตรงกันนี้ถูกเรียกว่าการ<em>curry</em>และ<span class="math inline">\(h\)</span>ถูกเรียกเป็นรูปแบบที่ผ่านการcurryแล้วของ<span class="math inline">\(g\)</span></p>
<p>ความตรงกันนี้เป็นแบบหนึ่งต่อหนึ่งเพราะว่าถ้ามี<span class="math inline">\(g\)</span>ใดๆก็ตามก็จะมี<span class="math inline">\(h\)</span>ที่เป็นเอกลักษณ์(และอันเดียว) และถ้ามี<span class="math inline">\(h\)</span>ใดๆก็ตามคุณสามารถที่จะสร้างfunctionที่มีสองargumentใหม่โดยการใช้สูตรดังนี้</p>
<p><span class="math display">\[
g = \operatorname{eval}\circ(h\times\operatorname{id})
\]</span></p>
<p>function<span class="math inline">\(g\)</span> สามารถถูกเรียกว่ารูปแบบของ<span class="math inline">\(h\)</span>ที่ถูก<em>uncurried</em>แล้ว</p>
<p>การcurryนั้นจริงๆแล้วถูกสร้างภายในsyntaxของHaskell โดยที่มีfunctionที่นำfunctionกลับมา</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>ที่มักจะถูกคิดว่าเป็นfunctionที่มีสองตัวแปร นั้นคือวิธีการที่เราอ่านรูปแบบของsignatureโดยที่ไม่มีวงเล็บ</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>การตีความนี้นั้นชัดเจนในทางที่ว่าเรานิยามfunctionที่มีหลายargument ตัวอย่างเช่น</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">catstr ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>catstr s s' <span class="ot">=</span> s <span class="op">++</span> s'</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>ในfunctionเดียวกันก็สามารถถูกเขียนในฐานะfunctionที่มีargumentเดี่ยว ในการreturn functionในlambda</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>catstr' s <span class="ot">=</span> \s' <span class="ot">-&gt;</span> s <span class="op">++</span> s'</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>นิยามทั้งสองนั้นเท่ากันและ ทั้งสองสามารถถูกใช้งานบางส่วนโดยแค่มีargumentตัวเดียว ได้สร้างfunctionที่มีargumentเดี่ยวในแบบที่ว่า</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">greet ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>greet <span class="ot">=</span> catstr <span class="st">"Hello "</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>ถ้าให้พูดอย่างเคร่งครัดfunctionที่มีตัวแปรสองตัวคือสิ่งที่นำpair (typeประเภทproduct)</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(a, b) <span class="ot">-&gt;</span> c</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>มันตรงไปตรงที่จะแปรระหว่างทั้งสองรูปแบบและทั้งสองfunction (ที่เป็นhigher order)การทำการเหล่านี้จะถูกเรียกว่า<code>curry</code>และ<code>uncurry</code></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">curry</span><span class="ot"> ::</span> ((a, b) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">curry</span> f a b <span class="ot">=</span> f (a, b)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>และ</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">uncurry</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> ((a, b) <span class="ot">-&gt;</span> c)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">uncurry</span> f (a, b) <span class="ot">=</span> f a b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>สังเกตว่า<code>curry</code>คือ<em>ตัวที่ทำการแยกตัวประกอบ</em> สำหรับการสร้างแบบสากลของวัตถุประเภทfunction สิ่งนี้ชัดเจนอย่างมากถ้ามันถูกเขียนในรูปแบบนี้</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factorizer ::</span> ((a, b) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c))</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>factorizer g <span class="ot">=</span> \a <span class="ot">-&gt;</span> (\b <span class="ot">-&gt;</span> g (a, b))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>(เตือนความจำ:ตัวที่ทำการแยกตัวประกอบสร้างfunctionที่ทำการแยกตัวประกอบ)</p>
<p>ในภาษาที่ไม่ใช่functionalอย่างC++การcurryนั้นเป็นไปได้แต่ไม่ตรงไปตรงมา คุณสามารถที่จะคิดถึงfunctionที่มีมากว่าหนึ่งargumentในC++ที่ตรงกันกับfunctionของHaskellที่นำtupleเข้ามา (ถึงแม้ในการทำให้สับสนมาชึ้น ในC++คุณสามารถที่จะนิยามfunctionที่นำ<code>std::tuple</code> รวมไปถึงfunctionแบบvariadicและfunctionที่นำlistแบบinitializerเข้ามา)</p>
<p>คุณสามารถที่จะใช้functionของC++ใช้template<code>std::bind</code> ตัวอย่างเช่นถ้ามีfunctionของสองstring</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c++ code-with-copy"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string catstr<span class="op">(</span><span class="bu">std::</span>string s1<span class="op">,</span> <span class="bu">std::</span>string s2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s1 <span class="op">+</span> s2<span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>คุณสามารถที่จะนิยามfunctionของstringตัวเดียว</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c++ code-with-copy"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>placeholders<span class="op">;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> greet <span class="op">=</span> <span class="bu">std::</span>bind<span class="op">(</span>catstr<span class="op">,</span> <span class="st">"Hello "</span><span class="op">,</span> _1<span class="op">);</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> greet<span class="op">(</span><span class="st">"Haskell Curry"</span><span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Scalaที่มีความเป็นfunctionalมากกว่าC++หรือJavaตกอยู่ระหว่างทั้งสอง ถ้าคุณคาดว่าfunctionที่คุณกำลังนิยามจะถูกใช้งานเป็นบางส่วน คุณสามารถนิยามมันด้วยlistของargumentหลายๆอย่าง</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c++ code-with-copy"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>def catstr<span class="op">(</span>s1<span class="op">:</span> String<span class="op">)(</span>s2<span class="op">:</span> String<span class="op">)</span> <span class="op">=</span> s1 <span class="op">+</span> s2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>แน่นอนว่าสิ่งนี้จำเป็นต้องมีการคาดเดา/วางแผนล่วงหน้าของคนเขียนlibrary</p>
</section>
<section id="exponential" class="level2" data-number="10.3">
<h2 data-number="10.3" class="anchored" data-anchor-id="exponential"><span class="header-section-number">10.3</span> Exponential</h2>
<p>ในงานทางคณิตศาสตร์ (mathematical literature) วัตถุประเภทfunctionsหรือhom-objectภายในระหว่างสองวัตถุ<span class="math inline">\(a\)</span>และ<span class="math inline">\(b\)</span> มักจะถูกเรียกว่า<em>exponential</em>และถูกเขียนโดย<span class="math inline">\(b^a\)</span> สังเกตว่าtypeของargumentนั้นจะอยู่ข้างบน การเขียนรูปแบบนี้อาจจะดูแปลกในตอนแรก แต่มันมีเหตุผลที่ชัดเจนมากถ้าคุณคิดถึงความสัมพันธ์ระหว่างfunctionกับproduct เราได้เห็นแล้วว่าเราต้องใช้productในการสร้างแบบสากลของhom-objectภายใน แต่ความสัมพันธ์นั้นไปลึกกว่านั้น</p>
<p>มันดีที่สุดในตอนที่คุณพิจารณาfunctionระหว่างtypeจำกัด (typeที่มีจำนวนของค่าที่จำกัดอย่าง <code>Bool</code> <code>Char</code> หรือแม้กระทั้ง<code>Int</code>หรือ<code>Double</code>) functionอย่างนี้ อย่างน้อยในหลักการ สามารถที่จะถูกจดจำหรือแปลงให้เป็นdata structureที่สามารถถูกค้นหาได้ และสิ่งนี้คือแก่นแท้ของความเท่ากับระหว่างfunction(ที่ก็คือmorphism)และtypeแบบfunction(ที่ก็คือวัตถุ)</p>
<p>ตัวอย่างเช่นในfunctionที่pureจาก<code>Bool</code>นั้นถูกระบุได้อย่างทั้งหมดโดยคู่ของค่าต่างๆ หนึ่งในนั้นคู่กับ<code>False</code>และอีกตัวหนึ่งคู่กับ<code>True</code> setของfunctionที่เป็นไปได้ทั้งหมดจาก<code>Bool</code>ไปยัง<code>Int</code>คือsetของคู่ทั้งหมกของ<code>Int</code> นี่เหมือนกับproduct<code>Int x Int</code>หรือในการเขียนที่สร้างสรรค์หน่อยก็จะเป็น <code>Int^2</code></p>
<p>ในอีกตัวอย่างหนึ่ง เรามาดูที่typeของC++อย่าง<code>char</code>ที่ประกอบด้วย256ค่า (<code>Char</code>ของHaskellนั้นใหญ่กว่าเพราะว่าHaskellใช้Unicode) ได้มีหลายfunctionในส่วนของlibaryมาตราฐานของC++ที่มักจะถูกเขียนโดยการค้นหา functionอย่าง<code>isupper</code>หรือ<code>isspace</code>ถูกเขียนโดยการใช้ตาราง(table) ที่มีความเหมือนกับtupleของ256ค่าของBoolean tuple นี่คือtypeประเภทproductดังนั้นเรากำลังทำงานกับproductของBoolean 256ตัว <code>bool x bool x bool x ... x bool</code> เรารู้จากเลขคณิตว่าproductช้ำๆนิยามการยกกำลัง ถ้าคุณ”คูณ”<code>bool</code>ด้วยตัวเอง256(หรือ<code>char</code>)ครั้ง คุณก็จะได้<code>bool</code>ยกกำลัง<code>char</code>หรือ<code>bool^char</code></p>
<p>แล้วมีจำนวนเท่าไหร่ในtypeที่นิยามในแบบของtuple 256ตัวของ<code>bool</code> นั้นคือ<span class="math inline">\(2^{256}\)</span>เป้ะๆ นี้คือจำนวนของfunctionจาก<code>char</code>ไปยัง<code>bool</code>ที่แตกต่างกัน ที่แต่ละfunctionนั้นคู่กับtuple 256ตัวที่เป็นเอกลักษณ์(และอันเดียว) คุณสามารถที่จะคำนวนในแบบเดียวกันว่าจำนวนของfunctionจาก<code>bool</code>ไปยัง<code>char</code>ที่ก็คือ<span class="math inline">\(256^2\)</span>และอื่นๆ การเขียนแบบexponentialสำหรับtypeประเภทfunctionนั้นมีเหตุผลอย่างมากในกรณีเหล่านี้</p>
<p>เราคงจะไม่ต้องที่จะจำfunctionจาก<code>int</code>หรือ<code>double</code>ทั้งหมด แต่ในความเท่ากันระหว่างtypeประเภทfunctionและข้อมูลก็ยังอยู่ ถึงแม้มันจะไม่สามารถใช้ได้ในความเป็นจริง ได้มีtypeที่ไม่จำกัดตัวอย่างเช่นlist, stringและtree การพยายามที่จะจำfunctionเหล่านี้จากtypeเหล่านี้อาจจะต้องใช้พื้นที่จัดเก็บไม่จำกัด Haskellนั้นเป็นภาษาที่lazy(ขี้เกียจ)ดังนั้นขอบเขตระหว่างdata structureที่ถูกประเมินอย่างlazyและfunctionนั้นไม่ชัดเจน dualityของfunctionกับข้อมูลนี้ได้อธิบายวิธีการมอง(identificaiton)ของtypeประเภทfunctionของHaskell กับวัตถุexponentialในแบบcategoryที่มีความใกล้ทางความคิดของเราต่อ<em>ข้อมูล</em></p>
</section>
<section id="categoryแบบcartesian-closed" class="level2" data-number="10.4">
<h2 data-number="10.4" class="anchored" data-anchor-id="categoryแบบcartesian-closed"><span class="header-section-number">10.4</span> CategoryแบบCartesian Closed</h2>
<p>ถึงแม้ผมจะยังใช้categoryของsetในฐานะแม่แบบของtypesและfunction มันคุ้มที่จะเอ่ยถึงว่ามันมีชุดของcategoryที่ใหญ่กว่าและสามารถถูกใช้สำหรับวัตถุประสงค์นี้ categoryเหล่านี้ถูกเรียกว่า<em>Cartesian Closed</em> โดยที่<span class="math inline">\(\textbf{Set}\)</span>คือแค่หนึ่งในตัวอย่างของcategoryแบบนี้</p>
<p>categoryแบบcartesian closedต้องมี</p>
<ol type="1">
<li>วัตถุสุดท้าย</li>
<li>productของคู่ของวัตถุใดๆก็ตาม</li>
<li>exponentialของคู่ของวัตถุใดๆก็ตาม</li>
</ol>
<p>อยู่ ถ้าคุณพิจารณาexponentialในฐานะการทำproductช้ำๆ(อาจจะเป็นแบบไม่มีที่สิ้นสุด)แล้ว คุณสามารถที่จะคิดถึงcategoryแบบcartesian closedในฐานะสิ่งที่รองรับproductที่มีจำนวนเท่าใหร่ก็ได้ โดยเฉพาะวัตถุสุดท้ายที่สามารถถูกคิดในฐานะproductของวัตถุศูนย์ (หรือกำลังศูนย์ของวัตถุ)</p>
<p>สิ่งที่น่าสนใจเกี่ยวกับcategoryแบบcartesian closed จากมุมมองของวิทยาศาสตร์คอมพิวเตอร์คือมันให้modelอย่างง่ายสำหรับlambda calculusที่มีtypeแบบง่าย ที่เป็นพื้นฐานของภาษาโปรแกรมที่มีtypeทั้งหมด</p>
<p>วัตถุสุดท้ายและproductมีdualที่คือวัตถุเริ่มต้นและcoproduct categoryแบบcartesian closedที่ก็รองรับทั้งสอง และในที่productมีคุณสมบัติการแจกแจงเหนือcoproduct</p>
<p><span class="math display">\[
\begin{gather*}
  a \times (b + c) = a \times b + a \times c \\
  (b + c) \times a = b \times a + c \times a
\end{gather*}
\]</span></p>
<p>จะถูกเรียกว่าcategoryแบบ<em>bicartesian closed</em> เราจะเห็นในส่วนถัดไปว่าcategoryแบบbicartesian closedที่<span class="math inline">\(\textbf{Set}\)</span> เป็นตัวอย่างเด่นนั้นมีคุณสมบัติที่น่าสนใจ</p>
</section>
<section id="typeประเภทขอมลแบบพชคณตและexponentials" class="level2" data-number="10.5">
<h2 data-number="10.5" class="anchored" data-anchor-id="typeประเภทขอมลแบบพชคณตและexponentials"><span class="header-section-number">10.5</span> Typeประเภทข้อมูลแบบพีชคณิตและexponentials</h2>
<p>ในการตีความของtypeแบบfunctionในฐานะexponentialนั้นเข้าได้ดีกับแบบแผนของtypeประเภทข้อมูลแบบพีชคณิต ที่กลับกลายมาเป็นว่าสมการพื้นฐานทั้งหมดจากพีชคณิตในมัธยมปลายที่โยงความสัมพันธ์ของตัวเลขศูนย์และหนึ่ง การบวก การคูณและการยกกำลัง ยังคงไว้อยู่ในcategoryแบบbicartesian closedใดๆก็ตามสำหรับ วัตถุเริ่มต้นและสุดท้าย coproduct product และexponentialตามลำดับ เรายังไม่มีเครื่องมือที่จะพิสูจน์(อย่างadjunctionหรือlemmaของYoneda) แม้กระนั้นผมจะทำรายการของพวกมันในที่นี่ในฐานะแหล่งของความเข้าใจ(intuition)ที่มีประโยชน์</p>
<section id="ยกกำลงศนย" class="level3" data-number="10.5.1">
<h3 data-number="10.5.1" class="anchored" data-anchor-id="ยกกำลงศนย"><span class="header-section-number">10.5.1</span> ยกกำลังศูนย์</h3>
<p><span class="math display">\[
a^0=1
\]</span></p>
<p>ในการตีความแบบcategoricalเราแทนที่<span class="math inline">\(0\)</span>ด้วยวัตถุเริ่มต้น<span class="math inline">\(1\)</span>ด้วยวัตถุสุดท้ายและความเท่ากันด้วยisomorphism exponetialคือhom-objectภายใน exponentialนี้แสดงแทนsetของmorphismจากวัตถุเริ่มต้นไปยังวัตถุใดๆก็ตาม<span class="math inline">\(a\)</span> โดยความหมายของวัตถุเริ่มต้น ได้มีแค่morphismเดีี่ยวดังนั้นhom-set<span class="math inline">\(\textbf{C}(0,a)\)</span>คือsetที่มีสมาชิกเดีี่ยว setที่มีสมาชิกเดีี่ยวคือวัตถุสุดท้ายใน<span class="math inline">\(\textbf{Set}\)</span>ดังนั้นสมการนี้จึงถูกต้องอย่างตรงไปตรงมาใน<span class="math inline">\(\textbf{Set}\)</span> สิ่งที่เราพูดถึงนั้นถูกต้องในbicartesian closedใดๆก็ตาม</p>
<p>ในHaskellเราแทนที่<span class="math inline">\(0\)</span>ด้วย<code>Void</code> <span class="math inline">\(1\)</span>ด้วยtypeแบบunitและ exponentialด้วยtypeประเภทfunction สิ่งที่ผมเสนอคือว่าsetของfunctionจาก<code>Void</code>ไปยังtype<code>a</code>ใดๆก็ตามนั้น เท่ากับtypeแบบunitที่คือtypeที่มีสมาชิกเดีี่ยว ในอีกความหมายหนึ่ง ได้มีแต่หนึ่งfunction<code>Void -&gt; a</code> แต่เราได้เห็นfunctionนี้มาก่อน โดยที่มันถูกเรียกว่า<code>absurd</code></p>
<p>มันนั้นยุ่งยากเล็กน้อยในสองเหตุผล หนึ่งในนั้นคือการที่ว่าในHaskellเราไม่มีtypeที่ไม่มีอะไรอยู่เลย(uninhabited types) ในทุกๆtypeเก็บ”ผลลัพธ์ของการคำนวณที่ไม่มีที่สิ้นสุด”หรือbottom เหตุผลที่สองคือการเขียนทั้งหมดของ<code>absurd</code>นั้นมีความเท่ากับเพราะว่า ไม่ว่ามันจะทำอะไร ไม่มีใครที่จะสามารถใช้งานมันได้ ไม่มีค่าที่จะถูกส่งเข้าไปใน<code>absurd</code> (และถ้าคุณสามารถที่จะส่งการคำนวณที่ไม่มีที่สิ้นสุดมันก็จะไม่คืนค่าอะไรกลับมา)</p>
</section>
<section id="ยกกำลงของหนง" class="level3" data-number="10.5.2">
<h3 data-number="10.5.2" class="anchored" data-anchor-id="ยกกำลงของหนง"><span class="header-section-number">10.5.2</span> ยกกำลังของหนึ่ง</h3>
<p><span class="math display">\[
1^a=1
\]</span></p>
<p>สมการนี้ในการตีความใน<span class="math inline">\(\textbf{Set}\)</span>นำนิยามของวัตถุสุดท้ายกลับมาที่ก็คือได้มีmorphismที่เป็นเอกลักษณ์(และอันเดียว) จากวัตถุใดๆก็ตามไปยังวัตถุสุดท้าย โดยทั่วไปhom-objectภายในจาก<span class="math inline">\(a\)</span>ไปยังวัตถุสุดท้ายนั้นisomorphicกับวัตถุสุดท้ายเอง</p>
<p>ในHaskellได้มีแค่functionอันเดียวจากtypeใดๆไปยังunit เราได้เห็นfunctionแล้วก่อนหน้านี้ มันถูกเรียกว่า<code>unit</code> คุณสามารถที่จะคิดถึงมันในฐานะfunction<code>const</code>ที่ถูกใช้ในบางส่วนต่อ<code>()</code></p>
</section>
<section id="ยกกำลงหนง" class="level3" data-number="10.5.3">
<h3 data-number="10.5.3" class="anchored" data-anchor-id="ยกกำลงหนง"><span class="header-section-number">10.5.3</span> ยกกำลังหนึ่ง</h3>
<p><span class="math display">\[
a^1 = a
\]</span></p>
<p>นี่คือการนำข้อสังเกตว่าmorphismจากวัตถุสุดท้ายกสามารถถูกใช้ในการเลือก”สมาชิก”ของวัตถุ<code>a</code>กลับมา setของmorphismแบบนี้จึงisomorphicกับวัตถุเอง ใน<span class="math inline">\(\textbf{Set}\)</span>และHaskell ความisomorphismนั้นอยู่ระหว่างสมาชิกของset<code>a</code>และfunctionที่เลือกสมาชิกเหล่านั้นคือ<code>() -&gt; a</code></p>
</section>
<section id="ยกกำลงของผลบวก" class="level3" data-number="10.5.4">
<h3 data-number="10.5.4" class="anchored" data-anchor-id="ยกกำลงของผลบวก"><span class="header-section-number">10.5.4</span> ยกกำลังของผลบวก</h3>
<p><span class="math display">\[
a^{b+c} = a^b\times a^c
\]</span></p>
<p>ในทางcategoryแล้ว สิ่งนี้บอกว่าexponentialจากcoproductของสองวัตถุนั้นisomorphicกับproductของexponentialทั้งสอง ในHaskellสมการแบบพีชคณิตนี้มีการตีความที่ใช้ได้จริง มันบอกเราว่าfunctionจากผลบวกของtypeทั้งสองนั้นเท่ากับคู่ของfunctionจากแต่ละtype นี่เป็นแค่case analysisที่เราใช้ในตอนที่นิยามfunctionบนtypeแบบsum แทนที่จะเขียนนิยามของfunctionคู่กับ<code>case</code> เรามักจะแยกมันไปยังสองfunction(หรือมากกว่า)ที่ทำงานกับconstructorของtypeแยกๆกัน ตัวอย่างเช่นนำfunctionจากtypeแบบsumอย่าง <code>(Either Int Double)</code></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Either</span> <span class="dt">Int</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>มันอาจจะถูกนิยามในฐานะคู่ของfunctionจาก<code>Int</code>และ<code>Double</code>ตามลำดับ</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>f (<span class="dt">Left</span> n) <span class="ot">=</span> <span class="kw">if</span> n <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">then</span> <span class="st">"Negative int"</span> <span class="kw">else</span> <span class="st">"Positive int"</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>f (<span class="dt">Right</span> x) <span class="ot">=</span> <span class="kw">if</span> x <span class="op">&lt;</span> <span class="fl">0.0</span> <span class="kw">then</span> <span class="st">"Negative double"</span> <span class="kw">else</span> <span class="st">"Positive double"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>ในที่นี้<code>n</code>คือ<code>Int</code>และ<code>x</code>คือ<code>Double</code></p>
</section>
<section id="exponentialsของexponentials" class="level3" data-number="10.5.5">
<h3 data-number="10.5.5" class="anchored" data-anchor-id="exponentialsของexponentials"><span class="header-section-number">10.5.5</span> ExponentialsของExponentials</h3>
<p><span class="math display">\[
(a^b)^c = a^{b\times c}
\]</span></p>
<p>นี่คือแค่วิธีการของการแสดงถึงการcurryในรูปแบบของวัตถุexponentialจริงๆ functionที่return functionกลับมานั้นเท่ากับfunctionจากproduct (ซึ่งก็คือfunctionที่มีargumentสองตัว)</p>
</section>
<section id="exponentialsบนproduct" class="level3" data-number="10.5.6">
<h3 data-number="10.5.6" class="anchored" data-anchor-id="exponentialsบนproduct"><span class="header-section-number">10.5.6</span> Exponentialsบนproduct</h3>
<p><span class="math display">\[
(a\times b)^c = a^c\times b^c
\]</span></p>
<p>ในHaskell functionที่ทำการreturn pairกลับมานั้นมีความเท่ากันกับคู่ของfunctionที่แต่ละตัวสร้างสมาชิกของคู่ที่ให้มา</p>
<p>มันค่อนข้างที่จะเหลือเชื่อวิธีการที่สมการที่เรียบง่ายของพีชคณิตระดับมัธยม สามารถถูกยกไปยังทฤษฎีcategoryและมีการใช้งานได้ในความเป็นจริงในการเขียนโปรแกรมแบบfunctional</p>
</section>
</section>
<section id="isomorphismของcurry-howard" class="level2" data-number="10.6">
<h2 data-number="10.6" class="anchored" data-anchor-id="isomorphismของcurry-howard"><span class="header-section-number">10.6</span> IsomorphismของCurry-Howard</h2>
<p>ผมได้พูดถึงแล้วเกี่ยวกับความตรงกันของtypeข้อมูลประเภทlogicและพีชคณิต type<code>Void</code> และtypeของunitอย่าง<code>()</code>ตรงกันกับfalseและtrue typeแบบproductและtypeแบบsumตรงกันกับconjunctionทางตรรกศาสตร์<span class="math inline">\(\wedge\)</span> (AND, และ) และdisjunction<span class="math inline">\(\vee\)</span>(OR, หรือ) ในแบบแผนนี้typeประเภทfunctionที่เราได้ทำการนิยาม จะตรงกันกับimplicationทางตรรกศาสตร์<span class="math inline">\(\Rightarrow\)</span> ในอีกความหมายหนึ่ง type<code>a -&gt; b</code>สามารถถูกเรียกในฐานะว่า”ถ้า<span class="math inline">\(a\)</span>แล้ว<span class="math inline">\(b\)</span>”</p>
<p>ตามมาจากisomorphismของCurry-Howard ทุกๆtypeสามารถถูกตีความในฐานะproposition (คือstatementหรือการตัดสินที่อาจจะเป็นจริงหรือไม่) propositionแบบนี้นั้นถูกพิจารณาว่าจริงถ้าtypeนั้นมีสมาชิกอยู่และไม่จริงถ้ามันไม่มี โดยเฉพาะการที่implicationทางตรรกศาสตร์นั้นมีค่าเป็นจริงถ้ามีtypeแบบfunctionที่ตรงกับมันมีสมาชิกอยู่ นั้นหมายความว่าได้มีfunctionของtypeนั้นอยู่ การเขียนของfunctionนั้นจึงเป็นการพิสูจน์ของทฤษฎีบท นั้นก็คือการเขียนโปรแกรมนั้นจึงเท่ากันกับการพิสูจน์ทฤษฎีบท เรามาดูในบางตัวอย่าง</p>
<p>เรานำfunction<code>eval</code>ที่เราได้นำมาในนิยามของวัตถุประเภทfunction โดยที่signatureของมันคือ</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> ((a <span class="ot">-&gt;</span> b), a) <span class="ot">-&gt;</span> b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>มันนำคู่ที่ประกอบด้วยfunctionและargumentของมัน และสร้างผลลัพธ์ที่มีtypeที่ถูกต้อง นี่คือการเขียนในHaskellของmorphismนี้</p>
<p><span class="math display">\[
\operatorname{eval} :: (a \Rightarrow b) \times a \to b
\]</span></p>
<p>ที่นิยามtypeประเภทfunction<span class="math inline">\(a\Rightarrow b\)</span>(หรือคือวัตถุexponentialอย่าง<span class="math inline">\(b^a\)</span>) เรามาแปลsignatureไปยังpredicateทางตรรกศาสตร์โดยการใช้isomorphismของCurry-Howard</p>
<p><span class="math display">\[
((a \Rightarrow b) \wedge a) \Rightarrow b
\]</span></p>
<p>นี่คือวิธีการที่คุณสามารถอ่านtype<span class="math inline">\(a\Rightarrow b\)</span>คือถ้ามันเป็นจริงก็หมายความว่า<span class="math inline">\(b\)</span>ตามมาจาก<span class="math inline">\(a\)</span> และถ้า<span class="math inline">\(a\)</span>เป็นจริงแล้ว<span class="math inline">\(b\)</span>ต้องเป็นจริง มันมีเหตุผลมากและสามารถทำความเข้าใจได้ สิ่งนี้รู้จักในฐานะ<em>modus ponens</em>ตั้งแต่สมัยโบราณแล้ว เราสามารถพิสูจน์ทฤษฎีบทนี้โดยการเขียนfunctionออกมาว่า</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> ((a <span class="ot">-&gt;</span> b), a) <span class="ot">-&gt;</span> b</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>eval (f, x) <span class="ot">=</span> f x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>ถ้าคุณให้คู่ที่ประกอบด้วยfunction<code>f</code>ที่นำ<code>a</code>เข้ามาและคืนค่าเป็น<code>b</code>และค่าจริงๆอย่าง<code>x</code>ของtype<code>a</code> ผมสามารถที่จะสร้างค่าจริงๆที่อยู่ในtype<code>b</code>โดยการแค่ใช้งานfunction<code>f</code>กับ<code>x</code> โดยการเขียนfuncionนี้ผมได้แสดงว่าtype<code>((a -&gt; b), a) -&gt; b</code> นั้นมีสมาชิกอยู่ ดังนั้น<em>modus ponens</em>นั้นจริงในlogicของเรา</p>
<p>แล้วถ้าเป็นprediateที่ไม่จริงอย่างชัดเจน? ตัวอย่างเช่นถ้า<span class="math inline">\(a\)</span>หรือ<span class="math inline">\(b\)</span>นั้นจริงแล้ว<span class="math inline">\(a\)</span>ต้องเป็นจริง</p>
<p><span class="math display">\[
a \vee b \Rightarrow a
\]</span></p>
<p>สิ่งนี้ไม่จริงอย่างชัดเจนเพราะว่าคุณสามารถเลือก<span class="math inline">\(a\)</span>ที่ไม่จริงและ<span class="math inline">\(b\)</span>ที่จริงและนี่คือตัวอย่างขัดแย้ง(counter-example)</p>
<p>ในการโยงpredicateนี้ไปยังsignatureของfunctionโดยการใช้ isomorphismของCurry-Howardเราก็จะได้</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Either</span> a b <span class="ot">-&gt;</span> a</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>ลองเขียนยังไงก็ตามคุณจะไม่สามารถที่จะเขียนfunctionนี้ได้ คุณไม่สามารถที่จะสร้างค่าของtype<code>a</code>ถ้าคุณเรียกด้วยค่าของ<code>Right</code> (จำไว้ว่าเรากำลังพูดถึงfunctionที่<em>pure</em>)</p>
<p>สุดท้ายแล้วเรา(กลับ)มาที่ความหมายของfunction<code>absurd</code></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">absurd ::</span> <span class="dt">Void</span> <span class="ot">-&gt;</span> a</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>ลองพิจารณาว่า<code>Void</code>แปลไปยังfalseเราก็จะมี</p>
<p><span class="math display">\[
\operatorname{false}\Rightarrow a
\]</span></p>
<p>ทุกๆอย่างตามมาจากความไม่จริง(Anything follows from falsehood/<em>ex falso quodlibet</em>) นี่คือหนึ่งในการพิสูจน์(เขียน)ของstatementนี้(function)ในHaskell</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>absurd (<span class="dt">Void</span> a) <span class="ot">=</span> absurd a</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>ที่ที่<code>Void</code>ถูกนิยามว่า</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Void</span> <span class="ot">=</span> <span class="dt">Void</span> <span class="dt">Void</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>เหมือนในทุกครั้งtype<code>Void</code>นั้นมีความชับช้อน นิยามนี้ทำให้มันเป็นไปไม่ได้ที่จะสร้างบางค่าเพราะว่าในการสร้างค่าๆหนึ่งคุณต้องให้ค่าๆหนึ่งกับมัน ดังนั้นfunction<code>absurd</code>ไม่สามารถที่จะถูกเรียก</p>
<p>ได้มีตัวอย่างที่น่าสนใจมากมาย แต่ก็มีด้านที่ใช้งานได้จริงของisomorphismของCurry-Howardจริงหรือเปล่า? อาจจะไม่ในการเขียนโปรแกรมทั่วๆไป แต่ได้มีภาษาโปรแกรมอย่างAgdaหรือCoqที่ใช้ข้อได้เปรียบของisomorphismของCurry-Howardในการพิสูจน์ทฤษฎีบท</p>
<p>คอมพิวเตอร์ไม่ได้แค่ช่วยนักคณิตศาสตร์ในการทำงานของพวกเขา มันได้ปฏิวัติรากฐานของคณิตศาสตร์ ในหัวข้อการวิจัยที่มาแรงในด้านที่เรียกว่าHomotopy Type Theory และการทฤษฎีtypeที่ตามมาและได้ผลประโยชน์ มันเต็มไปด้วย Booleans, integers, products coproducts typeประเภทfunctionและอื่นๆ และในการที่จะขจัดความสงสัยใน ทฤษฎีบทได้ถูกเขียนในCoqและAgda คอมพิวเตอร์นั้นกำลังปฏิวัติโลกใบนี้มากกว่าหนึ่งแบบ</p>
</section>
<section id="บรรณานกรม" class="level2" data-number="10.7">
<h2 data-number="10.7" class="anchored" data-anchor-id="บรรณานกรม"><span class="header-section-number">10.7</span> บรรณานุกรม</h2>
<ol type="1">
<li>Ralph Hinze, Daniel W. H. James, Reason Isomorphically! <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> (จงเหตุผลแบบisomorphic!) บทความนี้มีการพิสูจน์ของสมการพีชคณิตในมัธยมเหล่านี้ในทฤษฎีcategoryที่ผมเอ่ยถึงในบทนี้</li>
</ol>


</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p><a href="https://www.cs.ox.ac.uk/ralf.hinze/publications/WGP10.pdf">https://www.cs.ox.ac.uk/ralf.hinze/publications/WGP10.pdf</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../content/1.8/functoriality.html" class="pagination-link" aria-label="ความเป็นFunctor (Draft)">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">ความเป็นFunctor (Draft)</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../content/1.10/natural-transformations.html" class="pagination-link" aria-label="Natural Transformation (การแปลงแบบธรรมชาติ) (Sketch)">
        <span class="nav-page-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Natural Transformation (การแปลงแบบธรรมชาติ) (Sketch)</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>