# คำนำ (Draft)


> มาระยะหนึ่งแล้วที่ผมมีความคิดคร่าวๆของการเขียนหนังสือที่เกี่ยวกับทฤษฎีcategory
ที่จะเน้นไปที่โปรแกรมเมอร์ ลองสังเกตว่านี้ไม่ใช่นักวิทยาการคอมพิวเตอร์แต่เป็นโปรแกรมเมอร์
ที่เป็นวิศวกรแทนที่จะเป็นนักวิทยาศาสตร์ ผมรู้ว่านี่อาจจะฟังดูเพี้ยนและผมก็กลัวจริงๆ
ผมไม่สามารถปฏิเสธได้ว่ามันมีช่องว่างขนาดใหญ่ระหว่างวิทยาศาสตร์กับวิศวกรรมนั้นก็เพราะว่าผมเคยทำงานอยู่ทั้งสองฝั่งของรอยแตก
แต่ผมรู้สึกตลอดมาถึงแรงกดดันที่อย่างมากในการอธิบายสิ่งต่างๆ ผมมีคำชื่นชมอย่างล้นหลามต่อริชาร์ด
ไฟน์แมนผู้ที่เป็นผู้เชี่ยวชาญด้านการอธิบายแบบง่ายๆ ผมรู้ว่าผมไม่ไช่ไฟน์แมนแต่ผมจะพยายามให้ถึงที่สุด
ผมเริ่มจากการเผยแพร่คำนำนี้(ที่ควรที่จะให้แรงบันดาลใจกับผู้อ่านในการเรียนทฤษฎีcategory)
เพื่อหวังเป็นให้เป็นการเริ่มต้นของบทสนทนาและการชักชวนให้มีข้อเสนอแนะต่างๆ[^1]

สิ่งที่ผมจะทำ
ในเพียงไม่กี่ย่อหน้าคือการทำให้คุณเชื่อว่าหนังสือเล่มนี้ถูกเขียนมาสำหรับคุณและไม่ว่าจะมีคำแย้งแบบไหนที่คุณอาจจะมี
ก็ตามในการเรียนสาขาในคณิตศาสตร์ที่นามธรรมที่สุดใน"เวลาว่างที่เหลือเฟือ"ของคุณ
นั้นไม่มีน้ำหนักเลย

การมองในแง่ดีของผมนั้นมากจากข้องสังเกตต่างๆ
อย่างแรกคือทฤษฎีcategoryคือขุมสมบัติของไอเดียต่างๆในการเขียนโปรแกรมที่มีประโยชน์อย่างมาก คนที่เขียน
Haskell ได้นำทรัพยากรเหล่านี้มาใช้ตั้งนานแล้ว
และไอเดียต่างๆเหล่านี้ได้ค่อยๆซึมไปยังภาษาอื่นๆแต่กระบวนการนี้นั้นช้าเกินไป เราจึงจำเป็นต้องเร่งมัน

อย่างที่สอง ได้มีประเภทหลากหลายรูปแบบของคณิตศาสตร์ และพวกมันดึงดูดผู้ติดตามหลายรูปแบบ คุณอาจจะไม่ชอบ
calculus หรือ พีชคณิต(algebra) แต่นั้นไม่ได้หมายความว่าคุณจะไม่สนุกไปกับทฤษฎีcategory
จนผมอาจจะพูดได้ว่าทฤษฎีcategoryคือประเภทของคณิตศาสตร์ที่ค่อนข้างเหมาะสมสำหรับแนวคิดของโปรแกรมเมอร์
นั่นก็เพราะว่าทฤษฎีcategoryให้ความสนใจกับโครงสร้างแทนที่จะสนใจในสิ่งที่เฉพาะเจาะจง
มันทำงานกับโครงสร้างที่ทำให้โปรแกรมนั้น ประกอบกันได้ (Composable)

การประกอบกัน (Composition) เป็นรากฐานที่แท้จริงของทฤษฎีcategory
(มันคือส่วนหนึ่งของคำนิยามของcategoryมันเอง)
และผมจะเสนออย่างเต็มที่ว่าการประกอบกันคือแก่นแท้ของการเขียนโปรแกรม
เราได้ที่การประกอบสิ่งต่างๆมาโดยตลอด
ที่มาก่อนแนวคิดของsubroutineที่มาจากวิศวกรผู้ยิ่งใหญ่ตั้งนานแล้ว ในอดีตที่ผ่านมา
หลักการของการเขียนโปรแกรมเชิงโครงสร้าง (structural programming)
ที่ได้ปฏิวัติวิธีการเขียนโปรแกรมก็เพราะว่า
หลักการเหล่านี้ทำให้ชิ้นส่วนของโค้ดต่างๆสามารถประกอบกันได้ แล้วก็ตามมาจาก object oriented
programming ที่ก็เกี่ยวกับวัตถุต่างๆที่ประกอบกันแทบทั้งหมด functional programming
นั้นไม่แค่เกี่ยวกับ ที่ประกอบกันของfunctionและโครงสร้างข้อมูลแบบพีชคณิต (algebraic data structures)
(มันทำให้concurrencyประกอบเข้ากันได้) ที่เป็นบางอย่างที่แทบจะเป็นไปไม่ได้ในการเขียนโปรแกรมในแบบอื่นๆ

อย่างที่สาม
ผมมีอาวุธลับอยู่คือมีดแล่เนื้อที่ผมจะทำการย่อยคณิตศาสตร์ให้มันง่ายกับ(การอ่านโดย)โปรแกรมเมอร์
ในตอนที่คุณเป็นนักคณิตศาสตร์มืออาชีพ
คุณต้องระวังเป็นอย่างมากที่จะทำให้การข้อสมมติของคุณถูกต้องเสียก่อน
จำเป็นต้องตรวจสอบทุกๆประพจน์(statement)อย่างระเอียดและสร้างข้อพิสูจน์อย่างรัดกุม
นี่จึงทำให้การอ่านงานวิจัยหรือหนังสือทางคณิตศาสตร์นั้นยุ่งยากสำหรับคนภายนอก
ผมเป็นจบฟิสิกส์มาและในฟิสิกส์นั้นเราได้มีความก้าวหน้าอย่างน่าเหลือเชื่อโดยการใช้การให้เหตุผลโดยที่ไม่ต้องรัดกุมมากนัก
นักคณิตศาสตร์ได้หัวเราะให้กับ Dirac delta function ที่ถูกสร้างมาโดยนักฟิสิกส์ผู้ยิ่งใหญ่อย่าง P. A.
M. Dirac เพื่อแค่ที่จะแก้สมการเชิงอนุพันธ์บางตัว
แต่พวกเขาก็หยุดหัวเราะในตอนที่พวกเขาค้นพบสาขาของcalculusที่เรียกว่าทฤษฎีdistribution
ที่ทำให้แนวคิดที่ลึกซึ้ง(insights)ของDiracเป็นทางการ (formalized)

แน่นอนว่าในการนำข้อเสนอ(ทางคณิตศาสตร์)ที่ไม่รัดกุม ก็มักจะเป็นไปได้ที่คุณจะเสนอสิ่งที่ผิดอย่างชัดเจน
ดันนั้นผมจะพยายามทำให้มั่นใจได้ว่าได้มีทฤษฎีทางคณิตศาสตร์ที่แน่นหนาในการสนับสนุนข้อเสนอที่ไม่รัดกุม
ผมได้มีหนังสือ *Category Theory for the Working Mathematician* ที่เขียนโดย Saunders Mac Lane
อยู่ไว้ข้างเตียง

เนื่องว่านี้คือทฤษฎีcategory*สำหรับโปรแกรมเมอร์* ผมจะแสดงทุกๆแนวคิดที่สำคัญ (ทางคณิตศาสตร์)
ผ่านโค้ดคอมพิวเตอร์ คุณอาจจะได้ยินมาว่า
ภาษาต่างๆแบบFunctionalนั้นมีความใกล้เคียงกับคณิตศาสตร์มากกว่าภาษาแบบimperativeที่เป็นที่นิยมมากกว่า
ภาษาประเภทเหล่านี้ก็จะมีความสามารถในการabstractingที่มากกว่าเช่นกัน
ดันนั้นจึงมีความต้องการที่จะต้องเรียนรู้Haskellก่อนที่จะได้เห็นผลประโยชน์ของทฤษฎีcategory
แต่นี่ก็ความหมายว่าทฤษฎีcategoryไม่สามารถถูกใช้งานนอกเหนือไปจากการเขียนโปรแกรมแบบfunctionalและนี่ไม่เป็นจริงเลย
ดันนั้นผมก็จะให้ตัวอย่างจำนวนไม่น้อยในภาษาC++
นั้นก็หมายความว่าคุณจะต้องที่จะก้าวข้ามsyntax(ไวยากรณ์)ที่ไม่ค่อยสวยงาม
รูปแบบต่างๆ(patterns)ที่อาจจะไม่เด่นขึ้นมาจากพื้นหลังของความเวิ่นเว้อและคุณอาจจะต้องถูกบังคับให้ทำการ
copyและpaste แทนที่จะเป็นการทำabstractionที่ขั้นที่สูงกว่า
แค่นั้นก็เป็นเหมือนกับโปรแกรมเมอร์C++หลายคน

แต่คุณจะไม่สามารถหนีได้ถ้าHaskellยังอยู่ในความสนใจ คุณไม่ต้องเป็นโปรแกรมเมอร์Haskell
แต่คุณต้องการมันในฐานะภาษาสำหรับการร่างและจดไอเดียต่างๆที่จะถูกเขียนในภาษาC++
และนี้คือวิธีการที่ผมเริ่มต้นกับHaskellจริงๆ ผมพบว่าว่าsyntax(ไวยากรณ์)ที่รวบรัดและระบบtype
ที่มีความสามารถสูง เป็นตัวช่วยที่ดีในการทำความเข้าใจและการเขียนtemplates โครงสร้างข้อมูล (data
structure) และ algorithms แต่แต่เนื่องว่าผมไม่ได้คาดหวังที่คุณคนอ่างจะรู้การเขียนในภาษาHaskell
ผมจึงจะแนะนำมันอย่างช้าๆและอธิบายทุกๆอย่างระหว่างทาง

ถ้าคุณเป็นโปรแกรมเมอร์ที่มีประสบการณ์ คุณอาจจะถามตัวเองว่า:
เราได้เขียนโปรแกรมมาตั้งนานโดยที่ไม่ต้องกังวลเกียวกับทฤษฎีcategoryหรือวิธีการแบบfunctional
แล้วมีที่อะไรเปลี่ยน?
แน่นอนว่าเราไม่สามารถที่จะมองข้ามการที่ว่าได้มีมีการชึมเข้ามาของfeaturesแบบfunctionalในภาษาแบบimperativeอย่างช้าๆ
แม้กระทั้งJavaที่เป็นดั่งปราการของobject oriented programmingก็อนุญาตให้lambdaได้เข้ามา
C++ก็ได้กำลังพัฒนาอย่างก้าวกระโดด (ที่มีมาตรฐานใหม่แทบทุกไม่กี่ปี)
เพื่อที่จะตามโลกที่กำลังเปลี่ยนแปลงให้ทัน
การขยับแบบนี้ก็เพื่อเตรียมตัวสำหรับการเปลี่ยนแปลงอย่างพลิกผัน (disruptive change)
หรือนักฟิสิกส์จะเรียกว่าการเปลี่ยนวัฏภาค (phase transition)
ถ้าคุณอุ่นนำไปเรื่อยๆน้ำมันก็จะเดือดในสักวัน
เราอยู่ในตำแหน่งของกบที่จะต้องเลือกว่าเราจะว่ายต่อไปในน้ำที่ร้อนมากขึ้นหรือเริ่มที่จะหาทางเลือกอื่นๆ

![](images/img_1299.jpg){fig-align="center" width=300}


หนึ่งในสิ่งที่ขับเคลื่อนการเปลี่ยนแปลงครั้งใหญ่คือการปฎิวัติมัลติคอร์(multicore)
ประเภทของภาษาโปรแกรมที่ยังอยู่ (อย่าง การเขียนโปรแกรมแบบobject oriented)
ก็ไม่ได้เสนออะไรใหม่ให้คุณเลยในสิ่งที่เกี่ยวกับ concurrencyและการทำงานคู่ขนาน (parellelism)
ซ้ำร้ายยังสนับสนุนการออกแบบที่เต็มไปด้วยbugและอันตราย การปกป้องข้อมูล(data hinder)
ซึ่งเป็นแนวคิดตั้งต้นของภาษาแบบobject oriented
ในตอนที่ต้องถูกนำเข้าไปผสมกับการแบ่ง(sharing)และการเปลี่ยนรูป(mutation)
กลับกลายมาเป็นจุดเริ่มต้นของdata races
แนวคิดของการรวมกันระหว่างmutexกับข้อมูลที่มันปกป้องเป็นสิ่งที่ดีแต่น่าเสียดายที่lockนั้นไม่สามารถที่จะประกอบกันได้
และการซ้อนlockทำให้ปัญหาdeadlocksเกิดง่ายขึ้นและยากต่อการแก้

แต่แม้กระทั้งในกรณีที่ไม่มีconcurrency ในความชับช้อนของระบบของโปรแกรมที่มีมากขึ้น
ก็เป็นการทดสอบขีดจำกัดของ ความสามารถในการขยายตัวของรูปแบบการเขียนของimperative
หรือในอีกคำอธิบายที่ง่ายขึ้นก็หมายความว่าผลข้างเคียง(side effects)นั้นมีมากจนล้นมือในลักษณะแบบนี้
functions ที่มีผลข้างเคียงมักจะสะดวกและง่ายต่อการเขียน
ผลข้างเคียงต่างๆของพวกมันเหล่านี้สามารถ(ในทางหลักการ)สามารถูกเขียนลงใปในชื่อหรือcommentต่างๆ
ตัวอย่างเช่นfunctionที่มีชื่อว่า `SetPassword` หรือ `WriteFile`
นั้นก็ชัดเจนมากว่ามันจะทำการเปลี่ยนแปลงบางสถานะและก่อให้เกิดผลข้างเคียงและเราก็คุ้นเคยกับการจัดการสิ่งเหล่านี้
แต่ในตอนที่เราเริ่มที่จะประกอบfunctionต่างๆที่มีผลข้างเคียงต่อเข้ากับfunctionต่างๆที่ก็มีผลข้างเคียงและต่อๆกันไป
เป็นที่ปัญหาจะเริ่มปรากฏ
ไม่ได้เพราะว่าผลข้างเคียงแย่ในตัวมันเองแต่และอื่นๆแต่คือการที่พวกมันถูกซ่อนจากสายตาจึงทำให้การจัดการในขนาดที่กว้างขึ้นเป็นไปไม่ได้
ผลข้างเคียงไม่สามารถถูกใช้เป็นจำนวนมากได้และการเขียนโปรแกรมแบบimperativeนั้นเกี่ยวข้องกับผลข้างเคียงทั้งสิ้น

การเปลี่ยนแปลงของhardwareและความซับซ้อนของโปรแกรมที่มีมากขึ้นบังคับให้เราต้องคิดใหม่กับรากฐานของการเขียนโปรแกรม
เหมือนกับนักก่อสร้างมหาวิหารยิ่งใหญ่แบบgothicของยุโรป
เราได้ฝึกฝนการฝีมือของเราจนถึงจุดจำกัดทางวัสดุและโครงสร้าง
ได้มีมหาวิหารgothicที่ยังสร้างไม่เสร็จในBeauvais[^2]ที่ฝรั่งเศสที่เป็นเหมือนพยานให้กับ
การฝ่าฟันของมนุษย์อย่างลึกๆต่อข้อจำกัดต่างๆ
มันเคยถูกคาดหวังให้ชนะในทั้งความสูงและความสว่างเมื่อเทียบกับวิหารที่มีมาก่อนแต่มันกลับต้องมีปัญหาของทรุดตัวอยู่อย่างเรื่อยๆ
มาตรการเฉพาะกิจอย่างแท่งเหล็กและสิ่งรองรับที่เป็นไม้ป้องกันไม่ให้มันยุบตัวลงมา
แต่เห็นได้ชัดว่ามีสิ่งที่ผิดพลาดหลายอย่าง ในมุมมองสมัยใหม่
มันเป็นปาฎิหาริย์ที่โครงสร้างgothicได้สร้างเสร็จโดยที่ไม่ต้องมีการช่วยเหลือจากวัสดุศาสตร์ (materials
science), การสร้างแบบจำลองคอมพิวเตอร์ (computer model), finite element analysis
และเลขหรือฟิสิกส์ทั่วไป
ผมหวังว่าในคนในคนรุ่นถัดๆไปจะมีคำชื่นชมในแบบคล้ายๆกันต่อทักษะของการเขียนโปรแกรมที่เราได้แสดงออกมาผ่านการสร้างระบบปฏิบัติการที่ชับช้อน
web serversและโครงสร้างพื้นฐานของอินเทอร์เน็ตและถ้าให้พูดอย่างตรงๆแล้วพวกเขาจะควรที่จะชื่นชมเพราะว่าเราได้ทำสิ่งเหล่านี้จากรากฐาน
ทางเชิงทฤษฎีที่บอบบาง เราควรที่จะแก้รากฐานเหล่านี้ถ้าเราต้องการที่จะเดินไปต่อข้างหน้า


![มาตรการเฉพาะกิจในการป้องกันเพื่อไม่ให้มหาวิหารBeauvaisจากการพังทลาย](images/beauvais_interior_supports.jpg){fig-align="center"
width=300}



[^1]: คุณสามารถที่จะดูผมสอนสิ่งเหล่านี้ให้กับผู้ชมแบบสดๆที่
[https://goo.gl/GT2UWU](https://goo.gl/GT2UWU) หรือหรือค้นหาไปที่ "bartosz milewski category theory"
ใน YouTube.

[^2]:
[http://en.wikipedia.org/wiki/Beauvais_Cathedral](http://en.wikipedia.org/wiki/Beauvais_Cathedral)
